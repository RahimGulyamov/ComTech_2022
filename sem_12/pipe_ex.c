/* Программа 05-3.с, осуществляющая однонаправленную связь через pipe 
между процессом-родителем и процессом-ребенком */ 
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    int p_fd[2], ch_fd[2], result;
    size_t size;
    char resstring[14]; 
    /* Попытаемся создать pipe */

    if(pipe(p_fd) < 0){
        /* Если создать pipe не удалось, печатаем об этом сообщение
        и прекращаем работу */
        printf("Can\'t create p_pipe\n");
        exit(-1);
    }
    if(pipe(ch_fd) < 0){
        printf("Can\'t create ch_pipe\n");
        exit(-1);
    }

    /* Порождаем новый процесс */ 
    result = fork(); 
    if(result < 0){ 
        /* Если создать процесс не удалось, сообщаем об этом и 
        завершаем работу */
        printf("Can\'t fork child\n");
        exit(-1);
    } else if (result > 0) {
        /* Мы находимся в родительском процессе, который будет 
        передавать информацию процессу-ребенку. В этом процессе
        выходной поток данных нам не понадобится, поэтому 
        закрываем его.*/
        close(p_fd[0]);
        close(ch_fd[1]);
        /* Пробуем записать в pipe 14 байт, т.е. всю строку 
        "Hello, world!" вместе с признаком конца строки */
        size = write(p_fd[1], "Hello, child!", 14);
        if(size != 14){
            /* Если записалось меньшее количество байт, сообщаем
            об ошибке и завершаем работу */
            printf("Can\'t write all string\n"); 
            exit(-1); 
        } 
        
        /* Закрываем входной поток данных, на этом 
        родитель прекращает работу */
        close(p_fd[1]);
        size = read(ch_fd[0], resstring, 14);
        if(size < 0){

            /* Если прочитать не смогли, сообщаем об ошибке и
            завершаем работу */

            printf("Can\'t read string\n"); 
            exit(-1); 
        } 
        /* Печатаем прочитанную строку */
        printf("%s\n",resstring);
        /* Закрываем входной поток и завершаем работу */
        close(ch_fd[0]);
        printf("Parent exit\n");
    } else {
        /* Мы находимся в порожденном процессе, который будет 
        получать информацию от процесса-родителя. Он унаследовал
        от родителя таблицу открытых файлов и, зная файловые 
        дескрипторы, соответствующие pip, иможет его использовать.
        В этом процессе входной поток данных нам не 
        ипонадобится, поэтому закрываем его.*/
        close(p_fd[1]);
        close(ch_fd[0]);
        /* Пробуем прочитать из pip'а 14 байт в массив, т.е. всю
        записанную строку */
        size = read(p_fd[0], resstring, 14);
        if(size < 0){

            /* Если прочитать не смогли, сообщаем об ошибке и
            завершаем работу */

            printf("Can\'t read string\n"); 
            exit(-1); 
        } 
        /* Печатаем прочитанную строку */
        printf("%s\n",resstring);
        /* Закрываем входной поток и завершаем работу */
        close(ch_fd[0]);
        size = write(ch_fd[1], "Hello, parent", 14);
        if(size != 14){
            /* Если записалось меньшее количество байт, сообщаем
            об ошибке и завершаем работу */
            printf("Can\'t write all string\n"); 
            exit(-1); 
        } 
        /* Закрываем входной поток данных, на этом 
        родитель прекращает работу */
        close(ch_fd[1]);
    }
    return 0; 
}